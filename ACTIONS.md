# ACTIONS

本文档约定本仓库脚本与 CLI 的开发规范，以及每次新增/修改脚本后的文档更新要求。

## 适用范围

- `cli/` 下的命令行工具（`mason-cli`）
- 其他以“脚本”形式存在的工具（如新增的 node 脚本、构建脚本、发布脚本等）

## 目录与职责约定

- `cli/bin/`
  - 只做入口与转发，不写业务逻辑
  - 入口需要具备可执行 shebang：`#!/usr/bin/env node`
- `cli/src/index.js`
  - 统一注册所有命令
  - 保持命令注册清晰分组，并在最后调用 `program.parse(process.argv)`
- `cli/src/commands/`
  - 每个文件负责一个命令（或一个命令组）
  - 命令实现尽量保持“单一职责”，复杂逻辑拆到 `utils/` 或独立模块
- `cli/src/templates/`
  - 所有模板集中维护
  - 模板改动必须同步更新 README 的生成结果示例（若示例受影响）
- `cli/src/utils/`
  - 放置纯函数与可复用工具

## 命令设计规范

- 命令命名
  - 使用 kebab-case（例如 `gen-view`、`create-file`）
  - 避免与常见系统命令冲突
- 参数设计
  - 所有参数必须在 `commander` 中显式声明
  - 参数名保持一致：
    - `--overwrite` 表示覆盖
    - `--dirname <dirname>` 表示子目录
    - `--router-path <path>` 表示路由路径
- 默认行为
  - 默认不破坏用户已有文件
  - 覆盖行为必须通过 `--overwrite` 显式开启
- 输出与错误
  - 错误信息要可定位、可操作
  - 需要中止流程时使用非 0 退出码

## 代码风格与工程规范

- ESM
  - `cli` 包为 `type: module`，新增文件默认使用 ESM import/export
- 路径与文件
  - 使用 `path.resolve` / `path.join` 处理路径
  - 文件写入前尽量检查目录存在性
- 交互式命令
  - 使用 `inquirer`/`prompts` 时，输入校验必须完整
- 依赖变更
  - 增加或移除依赖后：
    - 更新 `cli/package.json`
    - 重新生成锁文件（仓库使用的包管理器以项目实际为准）

## 新增脚本/命令后的必做事项（强制）

每次开发完成一个新的脚本或新增/修改 CLI 命令后，必须完成以下动作：

1. 更新 `@README.md`
   - `@README.md` 指仓库根目录的 `README.md`
   - 需要新增或更新：
     - 脚本/命令的用途
     - 调用方式（命令、参数、示例）
     - 运行前置条件（Node 版本、包管理器、配置文件等）
     - 可能的副作用（会改哪些文件，会写入哪些目录）

2. 更新对应子模块 README（如适用）
   - 如果改动发生在 `cli/`，同时更新 `cli/README.md`

3. 自检
   - `--help` 输出与 README 一致
   - 示例命令可在本地执行（至少能跑到参数解析与提示阶段）

## README 更新规范

- 文档内容必须与实现一致，不允许“猜测性描述”
- 只使用纯文本与代码块
- 不使用 icon/emoji
- 示例命令使用统一前缀：

```bash
mason-cli <command> [options]
```

## 变更清单模板（建议）

每次提交包含新脚本/新命令时，建议在 PR 或提交信息中包含：

- 变更内容：新增/修改了哪些命令或脚本
- 使用方式：核心命令示例
- 文档更新：已更新根目录 `README.md` 与相关子模块 README
